<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[COLA和DDD]]></title>
    <url>%2F2019%2F08%2F05%2FCOLA%E5%92%8CDDD%2F</url>
    <content type="text"><![CDATA[cola和DDD的一些研究 为什么我们想引入cola研究cola之前, 先抛出两个问题 我们的系统遇到什么问题了 用什么方式能解决我们遇到的问题 我们所面临的问题蜂利器项目中, 动态表单有一个默认值的概念，也就是在用户处理到当前字段时，会给当前字段自动计算一个值。有默认值绑定了一个类型，这里类型的计算逻辑都不相同。目前我们有三种默认值类型: 手工输入(用户手工输入, 相当于无默认值) 选择其他字段(可以选择之前某个节点或表单上的字段) 读取子任务生成规则(依赖于子任务的默认值配置) 目前我们已知的还需要加上动态配置(支持表达式计算)类型。 那么，对于不同类型，我们现在是如何处理的呢。 1234567891011if (Objects.equals(FlowStructConstants.DefaultValueType.INPUT.getType(), abstractFieldVo.getDefaultValueType())) &#123; // .........&#125;else if (Objects.equals(FlowStructConstants.DefaultValueType.SELECT.getType(), abstractFieldVo.getDefaultValueType())) &#123; // ......... // ......... // .........&#125;else if (Objects.equals(FlowStructConstants.DefaultValueType.READ_RULE.getType(), abstractFieldVo.getDefaultValueType())) &#123; // .........&#125; 如上代码, 其中 ‘………’ 的逻辑可能会非常之复杂。 产品: 有个需求，给爷加个新的默认值类型ok，现在需要加上动态配置这种默认值类型。 简单，随便改一下代码1234567891011121314if (Objects.equals(FlowStructConstants.DefaultValueType.INPUT.getType(), abstractFieldVo.getDefaultValueType())) &#123; // .........&#125;else if (Objects.equals(FlowStructConstants.DefaultValueType.SELECT.getType(), abstractFieldVo.getDefaultValueType())) &#123; // ......... // ......... // .........&#125;else if (Objects.equals(FlowStructConstants.DefaultValueType.READ_RULE.getType(), abstractFieldVo.getDefaultValueType())) &#123; // .........&#125;else if (Objects.equals(FlowStructConstants.DefaultValueType.DYNAMIC_SETTING.getType(), abstractFieldVo.getDefaultValueType())) &#123; // .........&#125; 确实非常简单，只需要加一个if else 就能实现了。看起来没有太大问题，我们大多数系统中也是这样做的。 问题？各种if else逻辑掺杂在业务逻辑中，非常不利于阅读代码。 ok，总会有人看不下去，重构一把：123456789101112131415161718bean A implements DefaultValueResolver&#123; void method()&#123; // ... &#125; String support() &#123; return "input"; &#125;&#125;bean B implements DefaultValueResolver&#123; void method()&#123; // ... &#125; String support() &#123; return "dynamic_setting"; &#125;&#125;bean C ...bean D ... 你可以把他称为策略模式，也可以叫SPI，无所谓，总之它让我们的代码变得更优雅了，并且让测试流程也简单了很多——只需要关注新增点。 假设产品又需要加默认值类型。这时就非常方便了，只需要新加一个实现DefaultValueResolver的类。 产品: 又有个需求，子任务规则默认值不能再这里算，需要在xxx地方算好ok, 把子任务默认值计算的规则挪到xxx地方。 简单，随便改一下代码12345678910111213141516171819bean A &#123; void method() &#123; if (!Objects.equals(FlowStructConstants.DefaultValueType.READ_RULE.getType(), abstractFieldVo.getDefaultValueType())) &#123; DefalutValueResolver resolver = resolverMap.get(defalutValueType); readRule.method(); // ....... &#125; &#125;&#125;bean B &#123; void method() &#123; if (Objects.equals(FlowStructConstants.DefaultValueType.READ_RULE.getType(), abstractFieldVo.getDefaultValueType())) &#123; DefalutValueResolver readRule = new ReadRuleDefaultValueResoler(); readRule.method(); // ....... &#125; &#125;&#125; 我们会发现，if else又回来了？我们使用SPI的目的，就是为了减少if else，但是随着业务需求的变更，if else又被加回来了。是我们的设计出问题了吗？还是产品太XXX了，需求不合理？思考一下，我们怎么解决现在的问题。 有没有解决的银弹回到默认值计算的思考中，首先我们把问题拆解清楚。 我们有什么 12345678Entity A &#123; // 默认值类型 String defalutValueType; // 默认值规则 String defalutValueRule; // 计算出的默认值 List&lt;FormValue&gt; defalutValues;&#125; 我们有默认值类型和默认值计算规则，我们没有默认值。 我们需要做什么 我们需要算默认值。 如何得到我们需要的东西 默认值=calculate(类型，规则， 计算参数)。 说到这里，需要引入一个概念——DDD(领域驱动设计) DDD不谈虚的，直接上代码。 现在我们有一个实体——人，属性如下Bean12345678910111213141516171819202122public class Human &#123; private Lips lips; private Teeth teeth; public Lips getLips() &#123; return lips; &#125; public void setLips(Lips lips) &#123; this.lips = lips; &#125; public Teeth getTeeth() &#123; return teeth; &#125; public void setTeeth(Teeth teeth) &#123; this.teeth = teeth; &#125;&#125; 先忽略人的其他属性。我们现在只需要他的牙齿和嘴唇。 ok，现在我们有一个业务功能叫聚餐，对应的方法为 12345678910class A &#123; public void dinnerParty(List&lt;Human&gt; humanList) &#123; for (Human human : humanList) &#123; human.getLips().open(); human.getTeeth().chew(); human.getLips().close(); &#125; // ... &#125;&#125; 对于聚餐这个方法，每个聚餐的human都有一个吃饭的动作，我们简单点：吃饭由lips.open() + teeth.chew() + lips.close() 三个动作组成。 ok, 现在看一下这个方法，我们使用human对象干了什么12human.getLips();human.getTeeth(); 我们现在的系统中100%的实体代码都是这样写的(至少蜂利器和物流tms系统是)，非常典型的失血模式，对象+行为没有绑定在一起，是一个面向对象编程的反例。 那什么是正例呢，就刚才聚餐吃饭的动作，吃饭应该是human的一个行为,所以human中应该有一个这样的方法12345public void eat() &#123; this.lips.open(); this.teeth.chew(); this.lips.opent();&#125; 而聚餐方法则需修改为:12345678class A &#123; public void dinnerParty(List&lt;Human&gt; humanList) &#123; for (Human human : humanList) &#123; human.eat(); &#125; // ... &#125;&#125; 这样，我们在业务逻辑中，不需要关心领域的某个行为需要干什么事情，将领域和行为绑定在一起。业务逻辑只是帮助我们将每个领域的行为串联起来成为一个业务功能。 领域模型与行为绑定确定一个行为是否输入该领域模型还是属于业务逻辑是非常复杂并且没有固定规则的。比如我们现在有两个实体Company和Employee。12345class Company &#123; // 公司内所有员工 List&lt;Employee&gt; employeeList; // ...&#125; 123456class Employee &#123; Employee teamLeader; // 所负责工作 List&lt;Work&gt; workList; // ...&#125; 假设现在公司需要开除某员工，这个业务功能涉及到Company和Employee。开除这个行为是属于公司的，但是对于员工来说，没有开除这个行为。我们需要使用领域服务将这两个领域模型给聚合起来。1234567891011121314151617Service A &#123; void fire(Company company, Employee, employee) &#123; company.fire(); employee.handleOver(); &#125;&#125;Company &#123; void fire(Employee employee) &#123; employeeList.remove(employee); &#125;&#125;Employee &#123; void handleOver() &#123; teamLeader.addWork(workList); employeeRepository.delete(this); &#125;&#125; 现在。我们的service变得非常的轻量，只是把各个领域模型的行为给聚合成业务功能。 back to reality回到我们动态表单计算默认值的需求，如果用DDD，我们应该怎么实现呢？123456789101112131415Entity A &#123; @Inject Map&lt;String, DefalutValueResolver&gt; resolvers; // 默认值类型 String defalutValueType; // 默认值规则 String defalutValueRule; // 计算出的默认值 List&lt;FormValue&gt; defalutValues; void calculateDefaultValues(Map&lt;String, Object&gt; param) &#123; this.defalutValues = resolvers.get(defalutValueType).resolve(defalutValueRule, param); &#125;&#125; ok，接下来我们只需要关系的是，对不同的业务，在不同的时机调用A.calculateDefaultValues()来给A对象设置上默认值。 这里先留下一个问题，在数据中存在了依赖注入(最常见的应该会是一些操作持久化层的Component)。 DDD的好处？目前还没有尝到过DDD的甜头，无法给出评价 cola是怎么做的cola一个业务动作的流程 整个cola架构的一个业务动作的流程如图所示。总结出其中有几个非常重要的点： CommandBus Extension Tunnel EventBus DomainModel commandBus命令总线，用来寻找和控制命令的执行。 其中有两个基本概念 Command 命令：通过当前业务功能抽象出一个命令，如注册用户就是一个RegisterUser命令。 CommandExecutor 命令执行器：用来执行我们的命令。 Extension扩展点是为了解决同一个流程不同业务有不同处理逻辑而产生的。可以理解为if else逻辑的变种，但是更加强大并且更加友好。 Tunnel用来交互持久化操作，不需要关心使用哪种持久化方式，将各种如db、es、redis的实现逻辑隐藏在Tunnel底层，进行持久化操作的时候只需要关心Tunnel接口 EventBus事件总线，非常重要的一点。 Event在一次Command执行结束之后触发，当然一次Command执行结束之后可以触发多个Event。并且，Event可同步也可异步地执行。 比如，用户发起了一个流程，在创建流程结束之后，我们触发一个发送新建流程的Event，该Event发送一个流程新建的消息，感兴趣的业务方通过监听该消息做一些自己的业务逻辑。 DomainModel不过多介绍了。 CommandBus@Command注解：用来标志一个Command执行器，以便Bootstrap在初始化注册的时候将所有的Command加载到CommandHub中。1234567@Inherited@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Componentpublic @interface Command &#123;&#125; @Interceptor：用来标志一个拦截器，以便Bootstrap在初始化注册的时候将所有的Interceptor加载到InterceptorHub中。 command属性标志了该Interceptor作用域在哪个Command，如果为空，则为全局拦截器。123456789101112131415161718@Inherited@Component@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface PreInterceptor &#123; Class&lt;? extends com.alibaba.cola.dto.Command&gt;[] commands() default &#123;&#125;;&#125;@Inherited@Component@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface PostInterceptor &#123; Class&lt;? extends com.alibaba.cola.dto.Command&gt;[] commands() default &#123;&#125;;&#125; CommandInvocation：命令调用器，一个命令执行的模板。1234567891011121314151617public Response invoke(Command command) &#123; Response response = null; try &#123; preIntercept(command); response = commandExecutor.execute(command); &#125; catch(Exception e)&#123; response = getResponseInstance(command); response.setSuccess(false); ExceptionHandlerFactory.getExceptionHandler().handleException(command, response, e); &#125; finally &#123; //make sure post interceptors performs even though exception happens postIntercept(command, response); &#125; return response;&#125; ok, 介绍完了一些基本的概念，如果我们想引入cola，我们需要做什么呢？ 定义一个Command 定义一个CommandExecutor 为Command编写一些Interceptor，如果需要的话 在我们的DomainService入口将请求封装成Command 扔给CommandBus执行，返回结果 看起来是非常简单的，并且流程是非常标准统一易于理解的。 执行过程中我们需要注意的一些实现点： Command和CommandExecutor一一对应 Command模式下不应该有返回值(可以参考CQRS) Command和CommandExecutor必须实现我们的标准接口 ok，我们平时写代码的过程中大部分情况下是需要有返回值的，所以我们使用另外的方案来解决返回值的问题——Context or Command。将我们的返回值传入到Command或者Context中，最终需要返回值的方法从其中可以取得。 扩展点扩展点的设计思想和SPI基本一致，但是比SPI更复杂。因为需要区别业务身份，而SPI只是进行了简单的过滤。 对于业务身份识别，我们先看一张图。 我们可以把最左边的添加客户的流程抽象成基本流程，它是和业务无关的流程。说明了添加客服这个功能的流程，(类似于我们对抽象方法的定义)。而右边的就是每个不同业务的处理逻辑，在这个过程中，我们将每个处理流程抽象成一个扩展点。 如图添加客户有4个流程——参数校验、保存联系人、生成新的机会、添加到私海。那么这里我们就生成4个扩展点—— AddCustomerValidateExtPt AddCustomerRepositoryExtPt AddCustomerGenerateOpportunityExtPt AddCustomerAdd2PrivateSeaExtPt 每个业务实现自己的扩展点，扩展点的注解定义如下，bizCode是业务标志。1234567@Inherited@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Componentpublic @interface Extension &#123; String bizCode() default ColaConstant.DEFAULT_BIZ_CODE;&#125; 这里的bizCode会从context中取得，context是业务上下文。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Context&lt;T&gt; &#123; /** * bizCode is used for Extension, the naming should follow Java namespace. * * For example: "ali.tmall.supermarket" means it is "天猫超市的业务编码" */ private String bizCode; /** * This is the content for application customization, different application would have different Context content. * * For example: in a typical application, the content might contain before info * * String userId; * String roleName; * String orgId; * String operatorId; */ private T content; public String getBizCode() &#123; return bizCode; &#125; public void setBizCode(String bizCode) &#123; this.bizCode = bizCode; &#125; public T getContent() &#123; return content; &#125; public void setContent(T content) &#123; this.content = content; &#125; @Override public String toString() &#123; return "Context&#123;" + "bizCode='" + bizCode + '\'' + ", content=" + content + '&#125;'; &#125;&#125; 在初始化阶段，Bootstrap负责扫描所有的@Extension的注解，并且放入ExtensionRepository中。1234567@Componentpublic class ExtensionRepository &#123; @Getter private Map&lt;ExtensionCoordinate, ExtensionPointI&gt; extensionRepo = new HashMap&lt;&gt;();&#125; 其中ExtensionCoordinate类如下所示12345public class ExtensionCoordinate &#123; private String extensionPoint; private String bizCode;&#125; 也就是说，在应用启动阶段，Bootstrap扫描所有的@Extension注解，并且使用Extesion注解的key和被扫描类的类名作为key，类的单例对象作为value放入repository中。在需要扩展点调用的时候，使用如下方式1extensionExecutor.execute(XXXExtPt.class, context, extension -&gt; extension.method()); cola在执行扩展点的过程中，定位扩展点的方法如下：123456789101112131415161718192021222324252627282930313233343536/** * if the bizCode is "ali.tmall.supermarket" * * the search path is as below: * 1、first try to get extension by "ali.tmall.supermarket", if get, return it. * 2、loop try to get extension by "ali.tmall", if get, return it. * 3、loop try to get extension by "ali", if get, return it. * 4、if not found, try the default extension * @param targetClz */protected &lt;Ext&gt; Ext locateExtension(Class&lt;Ext&gt; targetClz, Context context) &#123; Ext extension; checkNull(context); String bizCode = context.getBizCode(); logger.debug("Biz Code in locateExtension is : " + bizCode); // first try extension = firstTry(targetClz, bizCode); if (extension != null) &#123; return extension; &#125; // loop try extension = loopTry(targetClz, bizCode); if (extension != null) &#123; return extension; &#125; // last try extension = tryDefault(targetClz); if (extension != null) &#123; return extension; &#125; throw new ColaException("Can not find extension with ExtensionPoint: "+targetClz+" BizCode:"+bizCode);&#125; 从注释可以非常清楚地看到cola加载扩展点的优先级，这里cola是保证了业务使用的扩展点会从bizCode中解析出至少一个扩展点。并且使用java命名的方式解决冲突(更长匹配优先)，这里就引出了我们系统如果需要使用cola框架的两个问题。 bizCode的定义通常意义上来说，我们的一个业务功能点会有多个扩展点。但是每个扩展点所用到的bizCode是不一致的。 比如说发起一个流程这个过程中，存在两个扩展点，AExtPt是用来根据用户类型不同来控制某些字段展示是否加密，BExtPt是用来根据不同的默认值类型来计算默认值。 这两个扩展点的BizCode是不一样的，而bizCode又存于Context中，所以我们应该用什么方式将这些不同的类型找到不同的扩展点呢？ 扩展点冲突假设我们现在有一个业务功能中，需要计算商品的subTitle。 subTitle的计算依赖于Goods的两个字段saleCategory和type。我们现在设计一个扩展点分别计算了5种类型的subTitle。123456789101112131415161718192021222324public class Goods &#123; /** * 销售分类 * &lt;li&gt;原价&lt;/li&gt; * &lt;li&gt;促销&lt;/li&gt; * ... */ @ExtensionField(target = SubTitleExtPt.class , order = 1) private String saleCategory; /** * 类型 * &lt;li&gt;食品&lt;/li&gt; * &lt;li&gt;图书&lt;/li&gt; * ... */ @ExtensionField(target = SubTitleExtPt.class, order = 2) private String type; private String subTitle;&#125; 1234567891011121314151617181920212223242526272829303132333435@Extension(extensionCode = "book")public class BookTypeSubTitleExtPt implements SubTitleExtPt &#123; @Override public void calculateSubTitle(Goods goods) &#123; &#125;&#125;@Extension(extensionCode = "food")public class FoodTypeSubTitleExtPt implements SubTitleExtPt&#123; @Override public void calculateSubTitle(Goods goods) &#123; &#125;&#125;@Extension(extensionCode = "principle")public class PrincipleCategorySubTitleExtPt implements SubTitleExtPt&#123; @Override public void calculateSubTitle(Goods goods) &#123; &#125;&#125;@Extension(extensionCode = "sale")public class SaleCategorySubTitleExtPt implements SubTitleExtPt&#123; @Override public void calculateSubTitle(Goods goods) &#123; &#125;&#125;@Extension(extensionCode = "#&#123;defalut&#125;")public class DefaultSubTitleExtPt implements SubTitleExtPt&#123; @Override public void calculateSubTitle(Goods goods) &#123; &#125;&#125; 我们首先面临的问题是：假设现在某个Goods对象type=food，saleCategory=sale。name它应该命中哪个规则呢？ ok，我们遇到问题了，解决办法也非常简单，加上一个扩展点1234567@Extension(extensionCode = "category-book.type-sale")public class FoodSaleSubTitleExtPt implements SubTitleExtPt&#123; @Override public void calculateSubTitle(Goods goods) &#123; &#125;&#125; 现在，type=food，saleCategory=sale的Goods能够正确地找到扩展点了。但是，type=book、clothes….saleCategory=sale、principal….这些Goods依旧找不到扩展点。我们真的需要为这么多Goods创建C(m,n)个扩展点吗? 当扩展点出现冲突的时候，我们需要怎么解决这些冲突呢？ 这几个问题，我们先放下，讨论点别的。 事件机制前往 https://blog.csdn.net/significantfrank/article/details/79614915]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>cola</tag>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO多路复用]]></title>
    <url>%2F2019%2F08%2F05%2FIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%2F</url>
    <content type="text"><![CDATA[IO多路复用IO多路复用其实是Unix下的一种并发编程模型。 Unix并发编程模型 多进程模型 IO多路复用 多线程模型 Select模式select函数通过输入一组文件描述符，内容对输入的这些文件描述符进行检测，是否其中有可操作的文件描述符，如果有，则返回描述符。最终应用对返回的描述符中的某个可操作描述符进行阻塞操作。 select函数会改变描述符 select函数的监听文件描述符的大小为1024 select函数只支持readfds、writefds、expectfds poll模式poll模式和select基本一致，但是输入的是一组pollfd。12345struct pollfd &#123; int fd; /* file descriptor */ short events; /* requested events */ short revents; /* returned events */&#125;; poll无大小限制 poll由于pollfd的模式，能提供更多的操作类型 epoll模式epoll是非常典型的事件驱动。 123int epoll_create(int size);int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); epoll只需要向内核注册某个监听的文件描述符和事件，epoll_ctl方法(用于注册以及修改文件描述符和事件) 调用epoll_wait方法可以得到某个文件描述符的事件，epoll_wait方法(用于等待注册的文件描述符发生io事件) 工作模式 LT 当内核给应用发送事件通知时，应用可以不立即处理，如果应用不处理的话，则下次发送事件通知时会继续通知 ET 当内核给应用发送事件通知时，应用必须立即处理，如果应用不处理，下次发送事件通知时不会继续发送 ET模式下必须使用非阻塞IO。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis加载和执行]]></title>
    <url>%2F2019%2F07%2F06%2Fmybatis%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[mybatis是如何加载和执行的？ MapperScannerConfigurer这是一个BeanFactoryPostProcessor, 会在spring ApplicationContext refresh早期被加载。 invokeBeanFactoryPostProcessors(beanFactory); 这个过程会扫描配置的mapper interface package, 并且将些interface加入需要实例化的bean中。123456789101112131415161718192021222324/** * &#123;@inheritDoc&#125; * * @since 1.0.2 */@Overridepublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123; if (this.processPropertyPlaceHolders) &#123; processPropertyPlaceHolders(); &#125; ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); scanner.setAddToConfig(this.addToConfig); scanner.setAnnotationClass(this.annotationClass); scanner.setMarkerInterface(this.markerInterface); scanner.setSqlSessionFactory(this.sqlSessionFactory); scanner.setSqlSessionTemplate(this.sqlSessionTemplate); scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName); scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName); scanner.setResourceLoader(this.applicationContext); scanner.setBeanNameGenerator(this.nameGenerator); scanner.registerFilters(); scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));&#125; MapperFactoryBean属性在实例化这些Mapper Interface的时候, 其实是实例化MapperFactoryBean的过程。在这个过程中, sqlSession会被注入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * Populate the bean instance in the given BeanWrapper with the property values * from the bean definition. * @param beanName the name of the bean * @param mbd the bean definition for the bean * @param bw BeanWrapper with bean instance */ protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) &#123; PropertyValues pvs = mbd.getPropertyValues(); if (bw == null) &#123; if (!pvs.isEmpty()) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, "Cannot apply property values to null instance"); &#125; else &#123; // Skip property population phase for null instance. return; &#125; &#125; // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the // state of the bean before properties are set. This can be used, for example, // to support styles of field injection. boolean continueWithPropertyPopulation = true; if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123; continueWithPropertyPopulation = false; break; &#125; &#125; &#125; &#125; if (!continueWithPropertyPopulation) &#123; return; &#125; if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // Add property values based on autowire by name if applicable. if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123; autowireByName(beanName, mbd, bw, newPvs); &#125; // Add property values based on autowire by type if applicable. if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; autowireByType(beanName, mbd, bw, newPvs); &#125; pvs = newPvs; &#125; boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE); if (hasInstAwareBpps || needsDepCheck) &#123; PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); if (hasInstAwareBpps) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) &#123; return; &#125; &#125; &#125; &#125; if (needsDepCheck) &#123; checkDependencies(beanName, mbd, filteredPds, pvs); &#125; &#125; applyPropertyValues(beanName, mbd, bw, pvs); &#125; 在此处, 进行MapperFactoryBean实例化的过程中, 需要将BeanDefinition中的PropertyValues取出来进行注入, 其中就将sqlSession注入了。 SqlSessionFactoryBean这个bean是需要我们在spring xml配置中进行设置。123456789101112/** * &#123;@inheritDoc&#125; */@Overridepublic void afterPropertiesSet() throws Exception &#123; notNull(dataSource, "Property 'dataSource' is required"); notNull(sqlSessionFactoryBuilder, "Property 'sqlSessionFactoryBuilder' is required"); state((configuration == null &amp;&amp; configLocation == null) || !(configuration != null &amp;&amp; configLocation != null), "Property 'configuration' and 'configLocation' can not specified with together"); this.sqlSessionFactory = buildSqlSessionFactory();&#125; 其中的mapperLocations是我们配置的mapper xml package的位置, 根据这个配置, SqlSessionFactoryBean会将这些Mapper.xml通过XMLMapperBuilder解析。 1234567891011public void parse() &#123; if (!configuration.isResourceLoaded(resource)) &#123; configurationElement(parser.evalNode(&quot;/mapper&quot;)); configuration.addLoadedResource(resource); bindMapperForNamespace(); &#125; parsePendingResultMaps(); parsePendingChacheRefs(); parsePendingStatements();&#125; bindMapperForNamespace这里就是我们平常在xml中配置的namespace绑定, 这个namespace就是我们制定的mapper.xml对应的mapper interface。 可以看到, 多个xml绑定了同一个namespace的时候, 并不会多次重复绑定。1234567891011121314151617181920private void bindMapperForNamespace() &#123; String namespace = builderAssistant.getCurrentNamespace(); if (namespace != null) &#123; Class&lt;?&gt; boundType = null; try &#123; boundType = Resources.classForName(namespace); &#125; catch (ClassNotFoundException e) &#123; //ignore, bound type is not required &#125; if (boundType != null) &#123; if (!configuration.hasMapper(boundType)) &#123; // Spring may not know the real resource name so we set a flag // to prevent loading again this resource from the mapper interface // look at MapperAnnotationBuilder#loadXmlResource configuration.addLoadedResource("namespace:" + namespace); configuration.addMapper(boundType); &#125; &#125; &#125;&#125; parsePendingResultMaps解析resultMap parsePendingChacheRefs解析cache 配置 parsePendingStatements解析sql语句 包括增删改查和配置的等。 校验 mybatis允许一个Mapper Interface对应多个Mapper xml。 条件: mybatis会将所有的resultMaps和MappedStatement等都放在Configuration中, 由Configuration自行实现的StrictMap储存。 map的key为namespace + id, 当存在相同的key时, put时候会抛出异常。 123456789101112131415161718192021protected static class StrictMap&lt;V&gt; extends HashMap&lt;String, V&gt; &#123; private static final long serialVersionUID = -4950446264854982944L; private final String name; @SuppressWarnings("unchecked") public V put(String key, V value) &#123; if (containsKey(key)) &#123; throw new IllegalArgumentException(name + " already contains value for " + key); &#125; if (key.contains(".")) &#123; final String shortKey = getShortName(key); if (super.get(shortKey) == null) &#123; super.put(shortKey, value); &#125; else &#123; super.put(shortKey, (V) new Ambiguity(shortKey)); &#125; &#125; return super.put(key, value); &#125;&#125; MapperProxyFactoryMapperProxyFactory使用JDK动态代理。12345678protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123; return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);&#125;public T newInstance(SqlSession sqlSession) &#123; final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy);&#125; MapperProxy实例化Mapper对象在每个bean需要注入的时候通过populateBean实例化并且注入到响应的bean中。 由于Mapper对象在BeanFactory中实际上是MapperFactoryBean。所以最终会通过MapperFactoryBean中的 123public T getObject() throws Exception &#123; return this.getSqlSession().getMapper(this.mapperInterface);&#125; 方法获取。 此时的sqlSession是在之前实例化MapperFactoryBean的时候，通过PropertyValues中属性注入的方式已经注入了。 之后的调用栈是 SqlSessionTemplate123public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123; return this.getConfiguration().getMapper(type, this);&#125; Configuration123public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; return mapperRegistry.getMapper(type, sqlSession);&#125; MapperRegistry1234567891011public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type); if (mapperProxyFactory == null) &#123; throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;); &#125; try &#123; return mapperProxyFactory.newInstance(sqlSession); &#125; catch (Exception e) &#123; throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e); &#125;&#125; 最终产生MapperProxy对象，完成之后，将mapper真正对应的mapperProxy对象注入到刚才需要populateBean的bean中。 调用mapper实际的调用其实是对mapperProxy的调用。 1234567891011121314@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, args); &#125; else if (isDefaultMethod(method)) &#123; return invokeDefaultMethod(proxy, method, args); &#125; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; final MapperMethod mapperMethod = cachedMapperMethod(method); return mapperMethod.execute(sqlSession, args);&#125; 在执行调用的sql的executor也是代理，实际上是一个Plugin对象。最终的调用是调用Plugin中的invoke方法。 123456789101112@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass()); if (methods != null &amp;&amp; methods.contains(method)) &#123; return interceptor.intercept(new Invocation(target, method, args)); &#125; return method.invoke(target, args); &#125; catch (Exception e) &#123; throw ExceptionUtil.unwrapThrowable(e); &#125;&#125; 在这里调用invoke的时候，会执行在该plugin中的interceptors。也就是我们mybatis支持的拦截器，这里的拦截器是Executor拦截器，也是就我们声明的 1@Intercepts(&#123; @Signature(type = ResultSetHandler.class, method = &quot;handleResultSets&quot;, args = &#123;Statement.class&#125;) &#125;) 我们也可以声明ResultSetHandler类型的拦截器，这个是作用于处理返回结果集的拦截器。 1@Intercepts(&#123; @Signature(type = ResultSetHandler.class, method = &quot;handleResultSets&quot;, args = &#123;Statement.class&#125;) &#125;) ResultSetHandler的处理是在如下两个方法中发生的。 123456@Overridepublic &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123; PreparedStatement ps = (PreparedStatement) statement; ps.execute(); return resultSetHandler.&lt;E&gt; handleResultSets(ps);&#125; 123456789101112@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass()); if (methods != null &amp;&amp; methods.contains(method)) &#123; return interceptor.intercept(new Invocation(target, method, args)); &#125; return method.invoke(target, args); &#125; catch (Exception e) &#123; throw ExceptionUtil.unwrapThrowable(e); &#125;&#125;]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Optional]]></title>
    <url>%2F2019%2F07%2F01%2FOptional-md%2F</url>
    <content type="text"><![CDATA[Optional的一些实践 returning value with get()结论：不要使用 Optional的本意是让我们去避免一些出乎意料的异常，如果使用get()就违背了Optional设计的初衷，很可能get()方法会在将来的release中deprecated掉，所以最好使用其他的方式来让我们更好地去控制null case。 orElse()和orElseGet()区别结论：使用orElseGet() orElse接收一个value orElseGet接收一个Supplier 最主要的区别： 123456789101112131415161718public static String getMyDefault() &#123; System.out.println(&quot;Getting Default Value&quot;); return &quot;Default Value&quot;;&#125;public static void main(String[] args) &#123; String text = &quot;Text present&quot;; System.out.println(&quot;Using orElseGet:&quot;); String defaultText = Optional.ofNullable(text).orElseGet(HashMapTest::getMyDefault); Assert.check(&quot;Text present&quot;.equals(defaultText)); System.out.println(&quot;Using orElse:&quot;); defaultText = Optional.ofNullable(text).orElse(getMyDefault()); Assert.check(&quot;Text present&quot;.equals(defaultText));&#125; 返回结果 123Using orElseGet:Using orElse:Getting Default Value 可以明显地看出来使用orElse即使前面的条件没有为空，他还是调用了orElse里面的方法，而orElseGet不会。orElseGet源码明显地表示了如果value的值为null，就会调用入参Supplier的get方法取value。 stream().findFirst().orElseGet()findFirst()返回的是一个Optional对象，但是在调用orElseGet()的时候，会返回Optional的value对象。 orElseThrow()throw出来的exception必须是 Runtime Exception 方法上显示声明会抛出的Exception]]></content>
      <categories>
        <category>java</category>
        <category>java8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Optinal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jackson-basic]]></title>
    <url>%2F2019%2F07%2F01%2Fjackson-basic-md%2F</url>
    <content type="text"><![CDATA[jackson序列化 所有jackson使用基本都是对ObjectMapper。1ObjectMapper mapper = new ObjectMapper(); object-&gt;json1mapper.writeValueAsString(result1); json-&gt;object1mapper.readValue(Jsonparser, Class&lt;T&gt;) serialize and deserialize12@JsonDeserialize(using = LocalDateTimeDeserializer.class)@JsonSerialize(using = LocalDateTimeSerializer.class) timeFormat123@JsonDeserialize(using = LocalDateTimeDeserializer.class)@JsonSerialize(using = LocalDateTimeSerializer.class)@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) json list to list12URL path = ListTest.class.getClassLoader().getResource(&quot;before.json&quot;);List&lt;Rel&gt; ll = mapper.readValue(path, new TypeReference&lt;List&lt;Rel&gt;&gt;()&#123;&#125;); https://www.baeldung.com/jackson-object-mapper-tutorial jackson wrapper json result12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@JsonInclude(JsonInclude.Include.NON_NULL)public class JsonResult&lt;T&gt; implements Serializable&#123; private T data; private int status; private String msg; @JsonCreator public JsonResult(@JsonProperty("status") int status, @JsonProperty("msg") String msg, @JsonProperty("data") T data)&#123; this.data = data; this.msg = msg; this.status = status; &#125; @JsonCreator JsonResult(@JsonProperty("status") int status)&#123; this.status = status; &#125; @JsonCreator JsonResult(@JsonProperty("status") int status, @JsonProperty("msg") String msg)&#123; this.status = status; this.msg = msg; &#125; @JsonCreator JsonResult(@JsonProperty("status") int status, @JsonProperty("data") T data)&#123; this.status = status; this.data = data; &#125; @JsonCreator JsonResult(@JsonProperty("data") T data)&#123; this.data = data; &#125; public T getData() &#123; return data; &#125; public int getStatus() &#123; return status; &#125; public String getMsg() &#123; return msg; &#125; public static &lt;T&gt; JsonResult&lt;T&gt; error(int status, String msg)&#123; return new JsonResult&lt;&gt;(status, msg); &#125; public static &lt;T&gt; JsonResult&lt;T&gt; create(int status)&#123; return new JsonResult&lt;&gt;(status); &#125; public static &lt;T&gt; JsonResult&lt;T&gt; create(T data)&#123; return new JsonResult&lt;&gt;(data); &#125; public static &lt;T&gt; JsonResult&lt;T&gt; success(T data)&#123; return new JsonResult&lt;&gt;(0, data); &#125; json 自定义LocalDateTime序列化器配置joda 时间的返回类型123456789public class HHMMTimeSerializer extends JsonSerializer&lt;LocalDateTime&gt; &#123; private static final DateTimeFormatter HHMM_FORMATTER = DateTimeFormat.forPattern("HH:mm"); @Override public void serialize(LocalDateTime value, JsonGenerator gen, SerializerProvider serializers) throws IOException, JsonProcessingException &#123; gen.writeString(value != null ? HHMM_FORMATTER.print(value) : "null"); &#125;&#125; 使用 1@JsonSerialize(using = HHMMTimeSerializer.class)]]></content>
      <tags>
        <tag>java</tag>
        <tag>jackson</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring Servlet ApplicationContext启动]]></title>
    <url>%2F2019%2F07%2F01%2Fspring-Servlet-ApplicationContext%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[spring Servlet ApplicationContext怎么启动? web.xml中DispatcherServlet配置123456789&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; With the above Servlet configuration in place, you will need to have a file called /WEB-INF/golfing- servlet.xml in your application; this file will contain all of your Spring Web MVC-specific components (beans). You can change the exact location of this configuration file through a Servlet initialization parameter (see below for details). 使用servlet-mapping中的servlet-name必须与servlet中的servlet-name一致，并且必须要在WEB-INF中配置一个${servlet-name}-servlet.xml的配置文件, 该配置文件包含了所有的Spring Web MVC定制的bean。 当然, 你也可以通过Servlet init-param来修改配置文件xml的路径。 MVC servlet的模型DispatcherServlet的上下文 Servlet WebApplicationContext Root WebApplicationContext 其中Servlet WebApplicationContext包含了Controller、view resolver 等等与MVC相关的beans。 ==如果在处理过程中Servlet WebApplicationContext找不到相关的beans, 则会委托给Root WebApplicationContext处理。== 通过下面的配置可以使Servlet WebApplicationContext为空, 全部由RootApplicationContext处理12345678910111213141516171819202122&lt;web-app&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/root-context.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; FrameworkServlet.initServletBeanTomcat中 initServlet(servlet)触发了Servlet的init再触发HttpServletBean的initServletBean最终触发FrameworkServlet的initServletBean。 12345678910111213141516171819202122232425262728293031/** * Overridden method of &#123;@link HttpServletBean&#125;, invoked after any bean properties * have been set. Creates this servlet's WebApplicationContext. */@Overrideprotected final void initServletBean() throws ServletException &#123; getServletContext().log("Initializing Spring FrameworkServlet '" + getServletName() + "'"); if (this.logger.isInfoEnabled()) &#123; this.logger.info("FrameworkServlet '" + getServletName() + "': initialization started"); &#125; long startTime = System.currentTimeMillis(); try &#123; this.webApplicationContext = initWebApplicationContext(); initFrameworkServlet(); &#125; catch (ServletException ex) &#123; this.logger.error("Context initialization failed", ex); throw ex; &#125; catch (RuntimeException ex) &#123; this.logger.error("Context initialization failed", ex); throw ex; &#125; if (this.logger.isInfoEnabled()) &#123; long elapsedTime = System.currentTimeMillis() - startTime; this.logger.info("FrameworkServlet '" + getServletName() + "': initialization completed in " + elapsedTime + " ms"); &#125;&#125; initWebApplicationContext其中initWebApplicationContext就是用来实例化Servlet ApplicationContext。 onRefresh刷新ApplicationContext, 其中initHandlerMappings和initHandlerAdapters。这两个初始化非常重要。HandlerMappings是用来处理请求的核心。123456789101112131415/** * Initialize the strategy objects that this servlet uses. * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects. */protected void initStrategies(ApplicationContext context) &#123; initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context);&#125; initHandlerMappings这个initHandlerMappings至少会实例化一个。 12345678910111213141516171819202122232425262728293031323334353637/** * Initialize the HandlerMappings used by this class. * &lt;p&gt;If no HandlerMapping beans are defined in the BeanFactory for this namespace, * we default to BeanNameUrlHandlerMapping. */private void initHandlerMappings(ApplicationContext context) &#123; this.handlerMappings = null; if (this.detectAllHandlerMappings) &#123; // Find all HandlerMappings in the ApplicationContext, including ancestor contexts. Map&lt;String, HandlerMapping&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false); if (!matchingBeans.isEmpty()) &#123; this.handlerMappings = new ArrayList&lt;HandlerMapping&gt;(matchingBeans.values()); // We keep HandlerMappings in sorted order. AnnotationAwareOrderComparator.sort(this.handlerMappings); &#125; &#125; else &#123; try &#123; HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class); this.handlerMappings = Collections.singletonList(hm); &#125; catch (NoSuchBeanDefinitionException ex) &#123; // Ignore, we'll add a default HandlerMapping later. &#125; &#125; // Ensure we have at least one HandlerMapping, by registering // a default HandlerMapping if no other mappings are found. if (this.handlerMappings == null) &#123; this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class); if (logger.isDebugEnabled()) &#123; logger.debug("No HandlerMappings found in servlet '" + getServletName() + "': using default"); &#125; &#125;&#125; 其中会递归地去把所有的父BeanFactory中的HandlerMapping实例化。这里也解释了为什么我们可以不配置Servlet ApplicationContext。因为最终它的parent ApplicationContext中的HandlerMapping都会被实例化。 12345678910111213141516171819202122public static &lt;T&gt; Map&lt;String, T&gt; beansOfTypeIncludingAncestors( ListableBeanFactory lbf, Class&lt;T&gt; type, boolean includeNonSingletons, boolean allowEagerInit) throws BeansException &#123; Assert.notNull(lbf, "ListableBeanFactory must not be null"); Map&lt;String, T&gt; result = new LinkedHashMap&lt;String, T&gt;(4); result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)); if (lbf instanceof HierarchicalBeanFactory) &#123; HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf; if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) &#123; Map&lt;String, T&gt; parentResult = beansOfTypeIncludingAncestors( (ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit); for (Map.Entry&lt;String, T&gt; entry : parentResult.entrySet()) &#123; String beanName = entry.getKey(); if (!result.containsKey(beanName) &amp;&amp; !hbf.containsLocalBean(beanName)) &#123; result.put(beanName, entry.getValue()); &#125; &#125; &#125; &#125; return result;&#125; initHandlerAdapters基本等同initHandlerMappings]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring启动</tag>
        <tag>ApplicationContext</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-Root-ApplicationContext启动]]></title>
    <url>%2F2019%2F07%2F01%2Fspring-Root-ApplicationContext%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[spring Root ApplicationContext容器怎么启动? web.xml的解析 WEB-INF/web.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt; &lt;display-name&gt;ripple-flow-order&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-config.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;requestLog&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;requestLog&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; web.xml的解析发生在tomcat中, tomcat 中的1org.apache.tomcat.util.descriptor.web.WebXml 解析后的web.xml对象。 当容器启动之后, 会触发容器启动的的listener执行。 web.xml中的listener org.apache.catalina.core.StandardContext#listenerStart 其中配置的listener会被tomcat解析，并且tomcat会将其加入到tomcat启动的listener中。 ContextLoaderListener实现了ServletContextListener接口, 所以在tomcat启动之后, 会执行ContextLoaderListener的contextInitialized方法 123456789/** ** Notification that the web application initialization ** process is starting. ** All ServletContextListeners are notified of context ** initialization before any filter or servlet in the web ** application is initialized. */ public void contextInitialized ( ServletContextEvent sce ); ContextLoaderListener初始化1234567/** * Initialize the root web application context. */@Overridepublic void contextInitialized(ServletContextEvent event) &#123; initWebApplicationContext(event.getServletContext());&#125; ContextLoaderListener进行初始化的过程是初始化root web application context的过程。这个过程读取的配置信息是在web.xml中的context-param 1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-config.xml&lt;/param-value&gt;&lt;/context-param&gt; 配置并刷新根上下文 org.springframework.web.context.ContextLoader#configureAndRefreshWebApplicationContext org.springframework.context.support.AbstractApplicationContext#refresh AbstractApplicationContext中的refresh方法是每个ApplicationContext都需要执行的用来刷新上下文配置的方法。 1. prepareRefresh设置一些基本的环境信息,应用中无法拿到一些系统的环境配置, 需要从tomcat给的ServletContext中取。 2. obtainFreshBeanFactory让子类实例化Application Context中的bean factory。 12345678910111213141516171819202122/** * Loads the bean definitions via an XmlBeanDefinitionReader. * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader * @see #initBeanDefinitionReader * @see #loadBeanDefinitions */@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123; // Create a new XmlBeanDefinitionReader for the given BeanFactory. XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context's // resource loading environment. beanDefinitionReader.setEnvironment(getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. initBeanDefinitionReader(beanDefinitionReader); loadBeanDefinitions(beanDefinitionReader);&#125; 在这个过程中, 生成bean factory的时候需要加载BeanDefinitions, 是由XmlWebApplicationContext进行。这个过程是把所有的在xml中配置的, 包括component-scan等都会注册成bean。 1org.springframework.beans.factory.xml.XmlBeanDefinitionReader#registerBeanDefinitions 3. prepareBeanFactory配置一些BeanPostProcessor和一些不需要自动注入的类, 这些类会在spring的上下文加载完成之后自动地去通知处理。(Aware类型) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Configure the factory's standard context characteristics, * such as the context's ClassLoader and post-processors. * @param beanFactory the BeanFactory to configure */protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; // Tell the internal bean factory to use the context's class loader etc. beanFactory.setBeanClassLoader(getClassLoader()); beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // Configure the bean factory with context callbacks. beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); // BeanFactory interface not registered as resolvable type in a plain factory. // MessageSource registered (and found for autowiring) as a bean. beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // Register early post-processor for detecting inner beans as ApplicationListeners. beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // Detect a LoadTimeWeaver and prepare for weaving, if found. if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123; beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); &#125; // Register default environment beans. if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); &#125; if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); &#125; if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); &#125;&#125; 4. postProcessBeanFactory从servletContext中取一些环境or系统信息注册。 注册request/session scopes。123456789101112/** * Register request/session scopes, a &#123;@link ServletContextAwareProcessor&#125;, etc. */@Overrideprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; beanFactory.addBeanPostProcessor(new ServletContextAwareProcessor(this.servletContext, this.servletConfig)); beanFactory.ignoreDependencyInterface(ServletContextAware.class); beanFactory.ignoreDependencyInterface(ServletConfigAware.class); WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext); WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, this.servletContext, this.servletConfig);&#125; 5. invokeBeanFactoryPostProcessors执行BeanFactoryPostProcessor。 123456789101112131415/** * Instantiate and invoke all registered BeanFactoryPostProcessor beans, * respecting explicit order if given. * &lt;p&gt;Must be called before singleton instantiation. */protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123; beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); &#125;&#125; Mybatis-config.xml中配置的MapperScannerConfigurer会在这里处理。 这里的scanner.scan方法是核心. 123456789101112131415161718192021222324/** * &#123;@inheritDoc&#125; * * @since 1.0.2 */@Overridepublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123; if (this.processPropertyPlaceHolders) &#123; processPropertyPlaceHolders(); &#125; ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); scanner.setAddToConfig(this.addToConfig); scanner.setAnnotationClass(this.annotationClass); scanner.setMarkerInterface(this.markerInterface); scanner.setSqlSessionFactory(this.sqlSessionFactory); scanner.setSqlSessionTemplate(this.sqlSessionTemplate); scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName); scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName); scanner.setResourceLoader(this.applicationContext); scanner.setBeanNameGenerator(this.nameGenerator); scanner.registerFilters(); scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));&#125; 最终, 所有的Mapper对应的接口生成的对象其实都是MapperFactoryBean。 6. registerBeanPostProcessors注册所有的BeanPostProcessor。注册顺序和之后的执行顺序: 实现了PriorityOrdered的BeanPostProcessor 实现了Ordered的BeanPostProcessor 其他nonOrdered的BeanPostProcessor 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static void registerBeanPostProcessors( ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123; String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false); // Register BeanPostProcessorChecker that logs an info message when // a bean is created during BeanPostProcessor instantiation, i.e. when // a bean is not eligible for getting processed by all BeanPostProcessors. int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length; beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount)); // Separate between BeanPostProcessors that implement PriorityOrdered, // Ordered, and the rest. List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;(); List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;(); List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;String&gt;(); List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;String&gt;(); for (String ppName : postProcessorNames) &#123; if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); priorityOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; orderedPostProcessorNames.add(ppName); &#125; else &#123; nonOrderedPostProcessorNames.add(ppName); &#125; &#125; // First, register the BeanPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors); // Next, register the BeanPostProcessors that implement Ordered. List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;(); for (String ppName : orderedPostProcessorNames) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); orderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; sortPostProcessors(orderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, orderedPostProcessors); // Now, register all regular BeanPostProcessors. List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;(); for (String ppName : nonOrderedPostProcessorNames) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); nonOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors); // Finally, re-register all internal BeanPostProcessors. sortPostProcessors(internalPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, internalPostProcessors); // Re-register post-processor for detecting inner beans as ApplicationListeners, // moving it to the end of the processor chain (for picking up proxies etc). beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext)); &#125; 这里只是进行注册, 之后的BeanPostProcessor的执行是在每个bean进行注册的时候做的。 7. initMessageSource国际化相关信息。 8. initApplicationEventMulticaster9. onRefresh留给子类扩展。 10. registerListeners注册ApplicationListener。1234567891011121314151617181920212223242526/** * Add beans that implement ApplicationListener as listeners. * Doesn't affect other listeners, which can be added without being beans. */protected void registerListeners() &#123; // Register statically specified listeners first. for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123; getApplicationEventMulticaster().addApplicationListener(listener); &#125; // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let post-processors apply to them! String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false); for (String listenerBeanName : listenerBeanNames) &#123; getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName); &#125; // Publish early application events now that we finally have a multicaster... Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents; this.earlyApplicationEvents = null; if (earlyEventsToProcess != null) &#123; for (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123; getApplicationEventMulticaster().multicastEvent(earlyEvent); &#125; &#125;&#125; 11. finishBeanFactoryInitializationbean加载最核心的地方 此处加载所有non-lazy-init的实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165/** * Return an instance, which may be shared or independent, of the specified bean. * @param name the name of the bean to retrieve * @param requiredType the required type of the bean to retrieve * @param args arguments to use when creating a bean instance using explicit arguments * (only applied when creating a new instance as opposed to retrieving an existing one) * @param typeCheckOnly whether the instance is obtained for a type check, * not for actual use * @return an instance of the bean * @throws BeansException if the bean could not be created */ @SuppressWarnings("unchecked") protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.debug("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference"); &#125; else &#123; logger.debug("Returning cached instance of singleton bean '" + beanName + "'"); &#125; &#125; bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // Fail if we're already creating this bean instance: // We're assumably within a circular reference. if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // Check if bean definition exists in this factory. BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. String nameToLookup = originalBeanName(name); if (args != null) &#123; // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; try &#123; final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'"); &#125; registerDependentBean(dep, beanName); try &#123; getBean(dep); &#125; catch (NoSuchBeanDefinitionException ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", ex); &#125; &#125; &#125; // Create bean instance. if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; else if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'"); &#125; try &#123; Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, "Scope '" + scopeName + "' is not active for the current thread; consider " + "defining a scoped proxy for this bean if you intend to refer to it from a singleton", ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; // Check if required type matches the type of the actual bean instance. if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) &#123; try &#123; return getTypeConverter().convertIfNecessary(bean, requiredType); &#125; catch (TypeMismatchException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Failed to convert bean '" + name + "' to required type '" + ClassUtils.getQualifiedName(requiredType) + "'", ex); &#125; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; return (T) bean; 处理depends-on 这里的处理过程是将需要实例化的bean的depends-on的bean先实例化，通过depends-on可以用来控制bean的加载顺序。 实例化singleton bean 处理生成bean。其中populateBean是用来处理依赖bean, initializeBean是用来进行bean的初始化。 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * Actually create the specified bean. Pre-creation processing has already happened * at this point, e.g. checking &#123;@code postProcessBeforeInstantiation&#125; callbacks. * &lt;p&gt;Differentiates between default bean instantiation, use of a * factory method, and autowiring a constructor. * @param beanName the name of the bean * @param mbd the merged bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a new instance of the bean * @throws BeanCreationException if the bean could not be created * @see #instantiateBean * @see #instantiateUsingFactoryMethod * @see #autowireConstructor */protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException &#123; // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); mbd.resolvedTargetType = beanType; // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; try &#123; applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Post-processing of merged bean definition failed", ex); &#125; mbd.postProcessed = true; &#125; &#125; // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references"); &#125; addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; return getEarlyBeanReference(beanName, mbd, bean); &#125; &#125;); &#125; // Initialize the bean instance. Object exposedObject = bean; try &#123; populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; &#125; catch (Throwable ex) &#123; if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123; throw (BeanCreationException) ex; &#125; else &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex); &#125; &#125; if (earlySingletonExposure) &#123; Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) &#123; if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException(beanName, "Bean with name '" + beanName + "' has been injected into other beans [" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + "] in its raw version as part of a circular reference, but has eventually been " + "wrapped. This means that said other beans do not use the final version of the " + "bean. This is often the result of over-eager type matching - consider using " + "'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."); &#125; &#125; &#125; &#125; // Register bean as disposable. try &#123; registerDisposableBeanIfNecessary(beanName, bean, mbd); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex); &#125; return exposedObject;&#125; 初始化bean 调用bean的各种init方法, 调用BeanPostProcessor的方法, 此处需要注意执行顺序。 bean的初始化方法执行顺序 invokeAwareMethods 实现了Aware的类, 设置Aware的信息 applyBeanPostProcessorsBeforeInitialization 让BeanPostProcessor预处理 invokeInitMethods 实现了InitializingBean, 设置afterPropertiesSet invokeCustomInitMethod 调用设置的initMethod。 applyBeanPostProcessorsAfterInitialization 让BeanPostProcessor后处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Initialize the given bean instance, applying factory callbacks * as well as init methods and bean post processors. * &lt;p&gt;Called from &#123;@link #createBean&#125; for traditionally defined beans, * and from &#123;@link #initializeBean&#125; for existing bean instances. * @param beanName the bean name in the factory (for debugging purposes) * @param bean the new bean instance we may need to initialize * @param mbd the bean definition that the bean was created with * (can also be &#123;@code null&#125;, if given an existing bean instance) * @return the initialized bean instance (potentially wrapped) * @see BeanNameAware * @see BeanClassLoaderAware * @see BeanFactoryAware * @see #applyBeanPostProcessorsBeforeInitialization * @see #invokeInitMethods * @see #applyBeanPostProcessorsAfterInitialization */protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, "Invocation of init method failed", ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; spring是允许循环依赖的, 如果设置了spring允许循环依赖, 出现循环依赖时, spring会预先实例化依赖, 让当前初始化的bean拥有一个依赖的引用, 在当前bean初始化完成之后,会将这个只实例化未初始化的依赖进行初始化。 12. finishRefresh初始化LifeCycle类Processor, 发布ApplicationContext初始化完成的Event。123456789101112131415161718/** * Finish the refresh of this context, invoking the LifecycleProcessor's * onRefresh() method and publishing the * &#123;@link org.springframework.context.event.ContextRefreshedEvent&#125;. */protected void finishRefresh() &#123; // Initialize lifecycle processor for this context. initLifecycleProcessor(); // Propagate refresh to lifecycle processor first. getLifecycleProcessor().onRefresh(); // Publish the final event. publishEvent(new ContextRefreshedEvent(this)); // Participate in LiveBeansView MBean, if active. LiveBeansView.registerApplicationContext(this);&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring启动</tag>
        <tag>ApplicationContext</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring事务]]></title>
    <url>%2F2018%2F12%2F18%2Fspring%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[transactional transaction propagation behaviors REQUIRED 如果当前存在一个事务，则直接使用这个事务，如果没有，就重新创建一个事务 SUPPORTS 如果当前存在一个事务，则直接加入这个事务，如果没有就以non-transactionally继续执行 MANDATORY 检查现在是否有事务存在，如果没有，throw an exception REQUIRES_NEW 总是会新开一个事务，如果当前已经存在了一个事务，则会把当前的事务挂起 NOT_SUPPORTED 不支持事务，如果当前已经存在事务，会将当前事务挂起 NEVER 不支持事务，如果当前已经存在事务，throw an exception NESTED 如果当前存在事务，则增加一个嵌套事务，如果不存在，则新开一个事务 transaction isolation level DEFAULT Use the default isolation level of the underlying datastore. READ_UNCOMMITTED dirty reads, non-repeatable reads and phantom reads can occur. READ_COMMITTED dirty reads are prevented; non-repeatable reads and phantom reads can occur. REPEATABLE_READ dirty reads and non-repeatable reads are prevented; phantom reads can occur. SERIALIZABLE dirty reads, non-repeatable reads and phantom reads are prevented. TransactionManagementConfigurationSelector 可以看出@Transactional注解生效的两种方式，一种是使用代理，一种是使用AspectJ。 ==可以通过以下注解指定实现方式== 1@EnableTransactionManagement(mode = AdviceMode.XXX) 不需要额外的配置，使用@EnableTransactionManagement注解，并且声明mode类型为AdviceMode.AspectJ，即可在同级调用开启事务。 Spring transactionglobal transaction and local transactionglobal: 可操作多源，如db和mq； local: 只能操作一种数据源。 declarative and programmaticdeclarative: 声明式事务(推荐)programmatic: 编程式事务 PlatformTransactionManagerSpring 的核心事务策略概念接口。 123456789public interface PlatformTransactionManager &#123; //getTransaction会返回一个事务，(依赖于事务传播行为，可能会新建一个事务或抛异常等等) TransactionStatus getTransaction( TransactionDefinition definition) throws TransactionException; void commit(TransactionStatus status) throws TransactionException; void rollback(TransactionStatus status) throws TransactionException;&#125; 123456789101112131415public interface TransactionStatus extends SavepointManager &#123; boolean isNewTransaction(); //如果创建了一个nested transaction, 则需要对当前的事务保存一个savepoint boolean hasSavepoint(); void setRollbackOnly(); boolean isRollbackOnly(); void flush(); boolean isCompleted();&#125; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy是DataSource的一个代理，属于lowest level ==The Spring Framework does not support propagation of transaction contexts across remote calls,== 回滚roll back is automatic only on unchecked exceptions mybatis &amp; spring一个使用 MyBatis-Spring 的主要原因是它允许 MyBatis 参与到 Spring 的事务管理中。而 不是给 MyBatis 创建一个新的特定的事务管理器,MyBatis-Spring 利用了存在于 Spring 中的 DataSourceTransactionManager。==在事务处理期间,一个单独的 SqlSession 对象将会被创建 和使用。当事务完成时,这个 session 会以合适的方式提交或回滚。== spring声明式事务的实现AOP和xml或注解结合，使用TransactionInterceptor和PlatformTransactionManager的实现结合来产生一个AOP代理去驱动事务。 使用spring aop xml配置事务。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- from the file 'context.xml' --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- this is the service object that we want to make transactional --&gt; &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt; &lt;!-- the transactional advice (what 'happens'; see the &lt;aop:advisor/&gt; bean below) --&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt; &lt;!-- the transactional semantics... --&gt; &lt;tx:attributes&gt; &lt;!-- all methods starting with 'get' are read-only --&gt; &lt;tx:method name="get*" read-only="true"/&gt; &lt;!-- other methods use the default transaction settings (see below) --&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- ensure that the above transactional advice runs for any execution of an operation defined by the FooService interface --&gt; &lt;aop:config&gt; &lt;aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/&gt; &lt;/aop:config&gt; &lt;!-- don't forget the DataSource --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt; &lt;property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/&gt; &lt;property name="username" value="scott"/&gt; &lt;property name="password" value="tiger"/&gt; &lt;/bean&gt; &lt;!-- similarly, don't forget the PlatformTransactionManager --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- other &lt;bean/&gt; definitions here --&gt;&lt;/beans&gt; The configuration shown earlier is used to create a transactional proxy around the object that is created from the fooService bean definition. 所有的这些配置都是用来创建围绕fooService bean的一个事务代理。 rollback for默认的配置: spring会默认设置事务为 rollback only，这意味着只有在遇到unchecked Exception的时候才会触发rollback。checked Exception抛出的时候不会触发rollback。设置rollback for可以使checked Exception也触发回滚。当然设置no-rollback-for可以让某些异常不回滚。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;aop:config&gt; &lt;aop:pointcut id="defaultServiceOperation" expression="execution(* x.y.service.*Service.*(..))"/&gt; &lt;aop:pointcut id="noTxServiceOperation" expression="execution(* x.y.service.ddl.DefaultDdlManager.*(..))"/&gt; &lt;aop:advisor pointcut-ref="defaultServiceOperation" advice-ref="defaultTxAdvice"/&gt; &lt;aop:advisor pointcut-ref="noTxServiceOperation" advice-ref="noTxAdvice"/&gt; &lt;/aop:config&gt; &lt;!-- this bean will be transactional (see the 'defaultServiceOperation' pointcut) --&gt; &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt; &lt;!-- this bean will also be transactional, but with totally different transactional settings --&gt; &lt;bean id="anotherFooService" class="x.y.service.ddl.DefaultDdlManager"/&gt; &lt;tx:advice id="defaultTxAdvice"&gt; &lt;tx:attributes&gt; &lt;tx:method name="get*" read-only="true"/&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;tx:advice id="noTxAdvice"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="NEVER"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;&lt;/beans&gt; tx:advice标签tx:method 默认值: The propagation setting is REQUIRED. The isolation level is DEFAULT. The transaction is read-write. The transaction timeout defaults to the default timeout of the underlying transaction system or none if timeouts are not supported. Any RuntimeException triggers rollback, and any checked Exception does not. 使用@Transactional注解注解生效xml配置: 123456789101112131415161718192021222324252627&lt;!-- from the file 'context.xml' --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- this is the service object that we want to make transactional --&gt; &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt; &lt;!-- enable the configuration of transactional behavior based on annotations --&gt; &lt;tx:annotation-driven transaction-manager="txManager"/&gt;&lt;!-- a PlatformTransactionManager is still required --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- (this dependency is defined somewhere else) --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- other &lt;bean/&gt; definitions here --&gt;&lt;/beans&gt; @Transactional注解1234@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documented 1.可以看到注解的适用范围是方法和类(包括接口和枚举) 2.作用保留: 运行期也会保留 3.可以被继承(指的是使用该注解的类)，寻找注解里面的annotaion type会向上查找 @Transactional注解实现需要注意:The Spring team recommends that you annotate only concrete classes (and methods of concrete classes) with the @Transactional annotation, as opposed to annotating interfaces. You certainly can place the @Transactional annotation on an interface (or an interface method), but this works only as you would expect it to if you use interface-based proxies. The fact that Java annotations are not inherited from interfaces means that, if you use class-based proxies (proxy-target-class=”true”) or the weaving-based aspect (mode=”aspectj”), the transaction settings are not recognized by the proxying and weaving infrastructure, and the object is not wrapped in a transactional proxy, which would be decidedly bad. spring推荐使用@Transactional在类或者类方法上，而不是接口。因为@AspectJ(class-based)形式不支持在接口上实现事务，并且如果是代理模式，使用CGLIB代理(class-based)的话，也不支持接口上实现事务。JDK的实现方式支持(Interface-based)。 When you use proxies, you should apply the @Transactional annotation only to methods with public visibility. If you do annotate protected, private or package-visible methods with the @Transactional annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings. If you need to annotate non-public methods, consider using AspectJ (described later).当注解使用在方法上的时候，@Transactional注解在默认的情况下(使用proxy)只能作用于public方法，如果需要作用在private或protected方法则需要使用AspectJ。这也就引出了另外一个问题，因为一般来说private方法是self-invocation的。 In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that self-invocation (in effect, a method within the target object calling another method of the target object) does not lead to an actual transaction at runtime even if the invoked method is marked with @Transactional. Also, the proxy must be fully initialized to provide the expected behavior, so you should not rely on this feature in your initialization code (that is, @PostConstruct). 另一个问题是当出现self-invocation的时候，在proxy mode实现方式下@Transactional注解是不生效的，并且proxy mode实现必须是要求在使用前你的bean已经被完全初始化了。 proxy和AspectJ的实现原理The default mode (proxy) processes annotated beans to be proxied by using Spring’s AOP framework (following proxy semantics, as discussed earlier, applying to method calls coming in through the proxy only). The alternative mode (aspectj) instead weaves the affected classes with Spring’s AspectJ transaction aspect, modifying the target class byte code to apply to any kind of method call. AspectJ weaving requires spring-aspects.jar in the classpath as well as having load-time weaving (or compile-time weaving) enabled. (See Spring configuration for details on how to set up load-time weaving.) 使用proxy的方式的时候，被代理的target进行方法调用的时候会先调用代理的方法，在代理的方法里面再对target方法进行调用。而使用AspectJ的时候，是直接修改了注解声明的类的字节码。AspectJ使用需要spring-aspects.jar和设置compile-time weaving(编译的时候强制使用AspectJ形式，很显然可以想到，因为AspectJ形式修改了类的字节码，类的byte code这是在编译的时候进行的)。 @Transactional优先级别12345678910111213@Transactional(readOnly = true)public class DefaultFooService implements FooService &#123; public Foo getFoo(String fooName) &#123; // do something &#125; // these settings have precedence for this method @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW) public void updateFoo(Foo foo) &#123; // do something &#125;&#125; 多个transaction manager12345678public class TransactionalService &#123; @Transactional("order") public void setSomething(String name) &#123; ... &#125; @Transactional("account") public void doSomething() &#123; ... &#125;&#125; 1234567891011&lt;tx:annotation-driven/&gt; &lt;bean id="transactionManager1" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; ... &lt;qualifier value="order"/&gt; &lt;/bean&gt; &lt;bean id="transactionManager2" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; ... &lt;qualifier value="account"/&gt; &lt;/bean&gt; 当未指定使用哪个transaction manager的时候，默认的manager将会被使用。 By default, a participating transaction joins the characteristics of the outer scope, silently ignoring the local isolation level, timeout value, or read-only flag (if any). Consider switching the validateExistingTransactions flag to true on your transaction manager if you want isolation level declarations to be rejected when participating in an existing transaction with a different isolation level. This non-lenient mode also rejects read-only mismatches (that is, an inner read-write transaction that tries to participate in a read-only outer scope). 对于”PROPAGATION_REQUIRED”传播级别，默认的时候，outer事务的配置会覆盖inner的事务配置，也就是说开启新的事务的时候会使用existing transaction的配置。当需要使用inner transaction的配置时，需要将transaction manager的setValidateExistingTransaction设置true。 logical transaction and physical transaction PROPAGATION_REQUIRED 强制会有一个physical transaction，当一个带事务的方法被调用时，会生成一个logical transaction，这些logical transaction的配置都不会生效，而是使用outer transaction定义的isolation level, timeout value, or read-only flag。但是在出现异常回滚的时候，logical transaction如果需要回滚，会setRollbackOnly，此时不管physical transaction的rollback-for等等，只要transaction被set rollback only(the only possible outcome of the transaction may be a rollback)，physical transaction也会被回滚。 PROPAGATION_REQUIRES_NEW 会创建新的physical transaction，并且在这个隔离级别下，transaction的配置不会继承outer transaction，可以声明自己的 isolation level, timeout, and read-only。并且inner transaction的回滚也不会影响outer transaction。 PROPAGATION_NESTED 多个savepoint，一个physical transaction。如果嵌套的transaction中有一个inner transaction回滚了，只是当前的savepoint需要回滚，不会影响整个physical transaction。 ==通过TransactionStatus判断的== 1234567891011121314151617public interface TransactionStatus extends SavepointManager, Flushable &#123; boolean isNewTransaction(); boolean hasSavepoint(); void setRollbackOnly(); boolean isRollbackOnly(); @Override void flush(); boolean isCompleted();&#125; transactionInterceptortransactionInterceptor的继承以及组合关系。可以看到transactionAspectSupport包含了transactionInfo内部类，而transactionInfo又组合了transactionStatus。 TransactionProxyFactoryBean transaction 是否开启1logger.info("isActualTransactionActive:&#123;&#125;, isSynchronizationActive:&#123;&#125;.", TransactionSynchronizationManager.isActualTransactionActive(), TransactionSynchronizationManager.isSynchronizationActive()); commit12 rollback12]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>事务</tag>
        <tag>Transactional</tag>
        <tag>transaction</tag>
      </tags>
  </entry>
</search>
